# 词法作用域

> 2019.12.19 @wsl

作用域可分为词法作用域和动态作用域。

大多数编程语言采用的是词法作用域；少数编程语言仍使用动态作用域，如Bash脚本、Perl中的一些模式等（见附录）。

## 1. 词法阶段

词法作用域就是定义在词法阶段的作用域。

作用域是**嵌套**存在的，逐级严格包含的。

作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。

> 全局变量会自动成为全局对象（比如浏览器中的window对象）的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问。如：window.a。
>
> 可以由此访问被同名变量所遮蔽的全局变量。但非全局的变量如果被遮蔽了，无论如何都无法被访问到。

无论函数**在哪里**被调用，也无论它**如何**被调用，它的词法作用域都**只由**函数被声明时所处的**位置**决定。

词法作用域查找**只会**查找**一级标识符**。

例如代码中引用了 foo.bar.baz，词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别接管对 bar 和 baz 属性的访问。

## 2. 欺骗词法

JavaScript 中有两种机制来欺骗词法，eval 和 with。注意欺骗词法作用域会导致性能下降。

### 2.1 eval() 函数

JavaScript 中的 eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。 

在执行 eval(..) 之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。 

```javascript
function foo(str, a) {
	eval( str ); // 欺骗！
	console.log( a, b );
}
var b = 2;
foo( "var b = 3;", 1 ); // 1, 3
```

如上例，eval执行的代码声明了一个变量b，从而修改了foo(...)的词法作用域。因此，console.log(...)在执行时，会在foo(...)内部同时找到a和b，外部作用域的同名变量b已经被遮蔽了。



在严格模式的程序中， eval(..) 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。

```javascript
function foo(str) {
	"use strict";
	eval( str );
	console.log( a ); // ReferenceError: a is not defined
}
foo( "var a = 2" );
```



JavaScript 中 还 有 其 他 一 些 功 能 效 果 和 eval(..) 很 相 似。 **setTimeout(..) **和 **setInterval(..) **的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。这些功能已经过时且并不被提倡。不要使用它们！

**new Function(..)** 函数的行为也很类似， 最后一个参数可以接受代码字符串，并将其转化为动态生成的函数（前面的参数是这个新生成的函数的形参）。这种构建函数的语法比eval(..) 略微安全一些，但也要尽量避免使用。

### 2.2 with 关键字

with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。

例如：

```javascript
var obj = {
	a: 1,
	b: 2,
	c: 3
};
// 单调乏味的重复 "obj"
obj.a = 2;
obj.b = 3;
obj.c = 4;
// 简单的快捷方式
with (obj) {
	a = 3;
	b = 4;
	c = 5;
}
```

然而，with会有一些副作用，考虑如下代码：

```javascript
function foo(obj) {
	with (obj) {
		a = 2;
	}
}
var o1 = {
	a: 3
};
var o2 = {
	b: 3
};
foo( o1 );
console.log( o1.a ); // 2

foo( o2 );
console.log( o2.a ); // undefined
console.log( a ); // 2——不好， a 被泄漏到全局作用域上了！
```

上述代码中创建了 o1 和 o2 两个对象。其中o1具有a属性，o2没有。foo(..) 函数接受一个 obj 参数，该参数是一个对象引用，并对这个对象引用执行了 with(obj) {..}。在 with 块内部，我们写的代码看起来只是对变量 a 进行简单的词法引用，实际上就是一个LHS 引用，并将 2 赋值给它。

将o1传递进去时，a＝2 赋值操作找到了 o1.a 并将 2 赋值给它 。而当 o2 传递进去， o2 并没有 a 属性，因此不会创建这个属性，o2.a 保持 undefined。 

但是可以注意到一个奇怪的副作用，实际上 a = 2 赋值操作创建了一个全局的变量 a。这是怎么回事？

with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。

> 尽管一个 `with` 块将一个对象视为一个词法作用域，但是在 `with` 块儿内部正常的 `var` 声明将不会被限制在这个 `with` 块的作用域中，而是被添加到with所处的函数作用域中。



with 声明实际上是根据你传递给它的对象凭空创建了一个**全新的词法作用域**。 

当我们将 o2 作为作用域时，其中并没有 a 标识符，因此进行了正常的 LHS 标识符查找。o2 的作用域、 foo(..) 的作用域和全局作用域中都没有找到标识符 a，因此当 a＝2 执行时，自动创建了一个全局变量（因为是非严格模式）。 

> 在严格模式下，with是被完全禁止的。而在保留核心功能的前提下，间接或非安全地使用eval(..) 也被禁止了。

### 2.3 性能

eval(..) 和 with 会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。 

JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。

但如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。

最悲观的情况是如果出现了 eval(..) 或 with，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。 

这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。 不要使用它们。



## 参考链接

[维基百科|文氏图](https://zh.wikipedia.org/wiki/%E6%96%87%E6%B0%8F%E5%9B%BE)

[第二章：词法作用域](https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/scope %26 closures/ch2.md)



## 附录：动态作用域

词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生在代码的书写阶段（假设你没有使用eval() 或 with）。

有如下代码：

```javascript
function foo() {
	console.log(a); // 输出?
}
function bar() {
	var a = 3;
	foo();
}
var a = 2;
bar();
```

词法作用域让 foo() 中的 a 通过 RHS 引用到了全局作用域中的 a，因此会输出 2。

而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，**作用域链是基于调用栈的**，而不是代码中的作用域嵌套。

因此，在动态作用域中，上例代码中的 foo() 在执行时将会输出 3。

为什么会这样？因为当 foo() 无法找到 a 的变量引用时，会顺着调用栈在调用 foo() 的地方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的，引擎会检查 bar() 的作用域，并在其中找到值为 3 的变量 a。

需要明确的是，事实上 JavaScript 并不具有动态作用域。它只有词法作用域，简单明了。但是 this 机制某种程度上很像动态作用域。

主要区别：词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。（this 也是！）词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。

