# V8内存管理和垃圾回收机制

JavaScript引擎的内存空间主要分为栈和堆。

## 栈

临时存储空间，主要存储局部变量和函数调用。

基本类型数据（Number、String、Boolean、Null、Undefined、Symbol、BigInt）保存在栈内存中。

引用类型数据保存在堆内存中，对应变量是一个指向堆内存中实际对象的引用，存在栈中。

对于函数，解释器创建了“调用栈”来记录函数的调用过程。每调用一个函数，解释器就把这个函数添加进调用栈，解释器会为被添加进来的函数创建一个栈帧（用来保存函数的局部变量以及执行语句）并立即执行。如果正在执行的函数还调用了其他函数，新函数会继续被添加进入调用栈。函数执行完成，对应的栈帧立即被销毁。

> 如何查看调用栈？
>
> 1、使用 console.trace() 向 Web 控制台输出一个堆栈跟踪
>
> 2、浏览器开发者工具进行断点调试

栈虽然很轻量，在使用时创建，使用结束后销毁，但是不是可以无限增长的，被分配的调用栈空间被占满时，就会引起”栈溢出“的错误。

> 为什么基本数据类型存储在栈中，引用数据类型存储在堆中？
>
> JavaScript 引擎需要用栈来维护程序执行期间的上下文状态，如果栈空间大了的话，所有数据都存放在栈空间里面，会影响到上下文切换的效率，进而影响整个程序的执行效率。

## 堆

堆空间存储的数据比较复杂，大致可以划分为5个区域：

- 代码区（Code Space）
- Map 区（Map Space）
- 大对象区（Large Object Space）
- 新生代（New Space）
- 老生代（Old Space）

![img](.\images\v8-memory.png)

新生代内存是临时分配的内存，存活时间短；老生代内存是常驻内存，存活时间长。



## 垃圾回收机制

随着程序的运行，堆中的数据会越来越多；栈由系统自动管理，所以需要一个机制来管理堆空间，这就是垃圾回收机制。



### Minor GC（Scavenger）

清道夫GC，主要管理新生代空间，保证新生代空间的紧凑和干净。新生代空间是最新产生的数据存活的地方，这些数据往往都是短暂的。新生代空间相对较小，大约在1M~8M，可以通过V8标志如 --max_semi_space_size 或 --min_semi_space_size 来控制新生代空间大小。



**Scavenge算法**将内存空间对半分为两个区域，一半是对象区域（from），一半是空闲区域（to）。

新对象会首先分配到 from 空间，当进行垃圾回收的时候，会先将 from 空间中的存活对象复制到 to 空间进行保存，对未存活对象的空间进行回收。

复制完成后，from 空间和 to 空间进行调换，to 空间会变成新的 from 空间，原来的 from 空间则变成 to 空间。

新生代内存回收频率很高，速度也很快，但是空间利用率很低，因为有一半的内存空间处于“闲置”的状态。

### 对象的晋升

新生代中多次回收仍然存活的对象会被转移到老生代内存中，这种现象称为**晋升**。有下面两种情况：

1. 对象从From空间复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一个新生代的清理，如果是，则复制到老生代中，否则复制到To空间中。
2. 对象从From空间复制到To空间时，如果To空间已经被使用了超过25%，那么这个对象直接被复制到老生代。

### Major GC（Mark-Sweep & Mark-Compact）

该GC主要负责老生代空间的紧凑和清理。当V8知道老生代空间无更多空间的时候就会触发这个GC。

老生代内存占用较多，如果使用 Scanvenge 算法，不仅会浪费一半空间，而且复制如此大块的内存消耗的时间也会相当长。V8 在老生代中的垃圾回收策略采用 Mark-Sweep 和 Mark-Compact 相结合。

#### 标记清除（Mark-Sweep）

老生代采用的是“标记清除”来回收未存活对象。

分为标记和清除两个阶段。标记阶段会遍历堆中所有的对象，并对存活的对象进行标记，清除阶段则是对未标记的对象进行清除。

#### 标记整理（Mark-Compact）

标记清除有一个问题就是，进行标记清除之后，内存空间往往是不连续的，会出现很多内存碎片。这种不连续的碎片空间中，遇到较大的对象时可能会由于空间不足而导致无法存储。

为了解决内存碎片的问题，需要使用另外一种算法——“标记整理（Mark-Compact）”。标记整理对待未存活对象不是立即回收，而是将存活对象移到另一端，然后直接清掉端边界以外的内存。

V8的老生代使用标记清除和标记整理结合的方式。主要采用标记清除算法，如果空间不足以分配从新生代晋升过来的对象时，才使用标记整理。

### V8的优化

#### 增量标记（Incremental Marking）

为了避免出现 JavaScript 运行程序与垃圾回收器看到的不一致的情况，进行垃圾回收的时候，都需要将正在运行的程序停下来，等待垃圾回收执行完成之后再恢复程序的执行，这种现象称为“全停顿”。如果需要回收的数据过多，那么全停顿的时间就会比较长，会影响其他程序的正常执行。

为了避免垃圾回收时间过长影响其他程序的执行，V8采用了增量标记的算法，将标记过程分成一个个小的子标记过程，让垃圾回收与 JavaScript 应用逻辑代码交替执行，直到标记阶段完成。

通俗理解，就是把垃圾回收这个大的任务分成一个个小任务，穿插在 JavaScript 任务中间执行，这个过程其实跟 React Fiber 的设计思路类似。

#### 惰性清理

由于标记完成后，所有对象都已经被标记，不是存活对象就是未存活对象，堆上多少空间格局已经确定。惰性清理就是先不着急释放那些未存活对象所占用的空间，而是延迟清理过程的执行。垃圾回收器可以根据需要逐一清理未存活对象所占用的内存页。

#### 其他

V8后续还引入了增量式整理（Incremental Compaction），以及并行标记和并行清理，通过并行利用多核CPU来提升垃圾回收的性能。



## 参考链接

[V8内存管理及垃圾回收机制](https://segmentfault.com/a/1190000023162310)

[V8垃圾回收？看这篇就够了！- Go 语言中文网](https://studygolang.com/articles/26423)

[浅谈V8引擎中的垃圾回收机制](https://segmentfault.com/a/1190000000440270)

