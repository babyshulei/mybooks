# 异步I/O

> 2020.02.11 @wsl

在众多高级编程语言或运行平台中，Node是首个将异步作为主要编程方式和设计理念。

Node的基调：异步I/O、事件驱动和单线程。

Nginx采用纯C编写。

Nginx具备面向客户端连接的强大能力，但受限于各种同步的编程语言。

Node既可以作为服务器去处理客户端的大量并发请求，也可以作为客户端面向网络中的各个应用进行并发请求。

## 1. 为什么要异步I/O

### 1.1 用户体验

前端通过异步可以消除掉UI阻塞的现象，但是前端获取资源的速度也取决于后端的响应速度。

I/O是昂贵的，分布式I/O是更昂贵的。

只有后端能够快速响应资源，才能让前端的体验变好。

### 1.2 资源分配

假设业务场景中有一组互不相关的任务需要执行，主流的解决方案有：

1. 单线程串行依次执行；
2. 多线程并行完成；

添加硬件资源是一种提升服务质量的方式，但并不是唯一的方式。

单线程同步编程模型会因阻塞I/O导致硬件资源得不到更优的使用；

多线程编程模型也因为编程中的死锁、状态同步等问题让人诟病。

Node的解决方案：

1. 利用单线程，远离多线程死锁、状态同步等问题；
2. 利用异步I/O，让单线程远离阻塞，以更好地使用CPU;

为了弥补单线程无法利用多核CPU的缺点，Node提供了类似前端浏览器中Web Works的子进程，该子进程可以通过工作进程高效地利用CPU和I/O。

## 2. 异步I/O实现现状

操作系统内核对I/O只有两种方式：

1. 阻塞；
2. 非阻塞；

阻塞I/O的特点：

1. 调用之后一定要等到系统内核层完成所有的操作后，调用才结束；

阻塞I/O造成了CPU等待I/O，浪费等待时间，CPU的处理能力不能得到充分利用。为了提高性能，内核提供了非阻塞I/O。非阻塞I/O和阻塞I/O的差别为调用之后会立即返回。

非阻塞I/O的缺点：

由于完整的I/O并没有完成，立即返回的并不是业务层期望的数据，仅仅是当前调用的状态。为了获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成。(轮询)

轮询：

1. read：最原始，性能最低的一种，通过重复调用来检查I/O的状态来完成完整数据的读取；
2. select：read的改进方案，通过对文件描述符上的事件状态来判断；
3. poll：select的改进方案，采用链表的方式避免数组长度的限制，其次能避免不需要的检查。但是当文件描述符较多的时候，性能依旧十分的低下;
4. epoll：Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进行休眠，直到事件将它唤醒。真实利用了事件通知、执行回调的方式，而不是遍历查询，所有不会浪费CPU、执行效率较高;
5. kqueue：与epoll类似，仅在FreeBSD系统存在；

轮询对于应用程序而言只能算是一种同步。

### 2.2 理想的非阻塞异步I/O

期望的完美的异步I/O应该是应用程序发起非阻塞调用，无须通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需在I/O完成后通过信号或回调将数据传递给应用程序。

### 2.3 现实的异步I/O

多线程的异步I/O：

通过让部分线程进行阻塞I/O或者非阻塞I/O加轮询技术连完成数据获取，让一个进程进行计算处理，通过线程之间的通信将I/O得到的数据进行传递，实现异步I/O。

Windows的IOCP:

调用异步方法，等待I/O完成之后的通知，执行回调，用户无须考虑轮询，但内部是线程池的原理，不同之处在于这些线程池由系统内核接手管理。

Node的libuv：

Node提供了libuv作为抽象封装层，使得所有平台兼容性的判断都由这层来判断，并保证上层的Node与下层的自定义的线程池及ICOP之间各种独立。









## 参考链接

<https://juejin.im/post/5e0ae69e5188253ab849c8a1>

