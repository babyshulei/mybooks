# 模块机制

> 2020.01.16 @wsl

Web1.0时代，JavaScript脚本语言的两个主要功能：

1. 表单验证；
2. 网页特效；

Web2.0时代，前端工程师利用JavaScript大大提升了网页的用户体验，经历了工具类库、组件库、前端框架、前端应用的变迁。

JavaScript的先天缺陷：**模块**。

高级语言的模块化机制：

1. Java-类文件；
2. Python-import机制；
3. Ruby-require;
4. PHP-include和require;

## 1. CommonJS规范

commonJS的愿景：希望JavaScript能够在任何地方运行。

### 1.1CommonJS的出发点

JavaScript规范的缺陷：

1. 没有模块系统；
2. 标准库较少；
3. 没有标准接口；
4. 缺乏包管理系统；

CommonJS规范中，CommonJSAPI可以编写的应用：

1. 服务端JavaScript应用程序；
2. 命令行工具；
3. 桌面图形界面应用程序；
4. 混合应用；

### 1.2 CommonJS的模块规范

CommonJS对模块的定义主要分为模块引用、模块定义和模块标识3个部分。 

**1. 模块引用**

采用require()方法；

```javascript
var math = require('math');
```

**2. 模块定义**

require()：引入外部模块；

exports：导出模块的方法或变量，唯一导出的出口；

module：代表模块自身；

```javascript
// math.js
exports.add = function (){
	var sum = 0,
	i = 0,
	args = arguments,
	l = args.lenght;
	while(i<l){
		sum += args[i++];
	}
	return sum;
}

//program.js
var math = require("math");
exports.increment = function (val){
	return math.add(val,1);
}
```

**3. 模块标识**

就是传递给require()方法的参数，必须是符合小驼峰命名的字符串，或者以**.**、**..**开头的相对路径，或绝对路径，可以没有后缀.js。

## 2. Node的模块实现

Node中引入模块经历的三个步骤:

1. 路径分析；
2. 文件定位；
3. 编译执行；

Node中，模块分为两种：

1. 核心模块(Node提供的模块)；

   核心模块部分在Node源代码的编译过程中，编译了二进制执行文件。在Node进程启动时，部分核心模块被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行两个步骤可以省略掉，并且在路径分析中优先判断，它的加载速度是最快的。

2. 文件模块(用户编写的模块)；

   文件模块在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。

### 2.1 优先从缓存加载

与前端浏览器会缓存静态脚本文件以提高性能一样，Node对引入过的模块都会进行缓存，以减少二次引入的开销。不同的是，浏览器仅缓存文件，而Node缓存的是编译和执行后的对象。

不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是**第一优先级**的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。

### 2.2 路径分析和文件定位

#### 1. 模块标识符分析

模块标识符在Node中的分类：

1. 核心模块，如http、fs、path等；
2. .或..开始的相对路径文件模块；
3. 以/开始的绝对文件模块；
4. 非路径形式的文件模块，如自定义的connect模块；

**核心模块**

核心模块的优先级仅次于缓存加载，在Node的源代码编译过程中，已经编译为二进制代码了，其加载过程最快。

**路径形式的文件模块**

在分析路径模块时，require()将路径转化为真实路径，以真实路径作为索引，将编译执行后的结果放在缓存中，以使二次加载更快，其加载速度慢于核心模块。

**自定义模块**

这类模块的查找最费时，也是所有方式最慢的一种。

模块路径：

Node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。

模块路径的生成规则如下所示：

- 当前文件目录下的node_modules目录。
- 父目录下的node_modules目录。
- 父目录的父目录下的node_modules目录。
- 沿路径向上逐级递归，直到根目录下的node_modules目录 

在加载的过程中， Node 会逐个尝试模块路径中的路径，直到找到目标文件为止。可以看出，当前文件的路径越深，模块查找耗时会越多，这是自定义模块的加载速度是最慢的原因。

#### 2. 文件定位

从缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程，大大提高了再次加载模块时的效率。

文件定位过程中，需要注意的细节,包括文件扩展名的分析、目录和包的处理。

**文件扩展名分析**

require()在分析标识符的过程中，出现标识符中不包含文件扩展名的情况，Node会按.js、.json、.node的次序补足扩展名，依次尝试。

在尝试的过程中，需要调用fs模块同步阻塞式地判断文件是否存在。

**目录分析和包**

在分析标识的过程中，require()通过分析文件扩展名之后，可能没有查找到对应的文件，但却得到一个目录，此时Node会将目录当做一个包来处理。

在这个过程中， Node对CommonJS包规范进行了一定程度的支持。首先， Node在当前目录下查找package.json （CommonJS包规范定义的包描述文件），通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。

而如果main属性指定的文件名错误，或者压根没有package.json文件， Node会将index当做默认文件名，然后依次查找index.js、 index.json、 index.node。

如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败的异常。 



## 参考链接

https://juejin.im/post/5e09da676fb9a01606717fb7







