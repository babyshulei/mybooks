# 复杂度分析

## 分析方法

### 事后统计法

通过运行代码，进行统计监控得到代码执行时间和占用的内存大小，进而评估算法的执行效率。

局限性：

- 测试结果非常依赖测试环境
- 测试结果受数据规模的影响很大



### 大O描述法

复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。

#### 时间复杂度

所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。即：

```
T(n) = O(f(n))
```

这就是**大 O 时间复杂度表示法**。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示**代码执行时间随数据规模增长的变化趋势**，所以，也叫作**渐进时间复杂度**（asymptotic time complexity），简称**时间复杂度**。

在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。

如何分析一段代码的时间复杂度？有几个常用方法：

1. 关注循环执行次数最多的一段代码
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

常见复杂度的量级有**多项式量级**和**非多项式量级**。如图：

![img](../images/complexity-n.jpg)

- O(1)
  一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。
- O(logn)、O(nlogn)
  O(logn)常见的有二分查找；O(nlogn)常见的有归并排序、快速排序。
- O(m+n)、O(m*n)
  代码的复杂度由两个数据的规模来决定，不能简单地利用加法原则，省略掉其中一项，而是需要m、n两个参数决定。

#### 空间复杂度

空间复杂度全称就是**渐进空间复杂度**（asymptotic space complexity），**表示算法的存储空间与数据规模之间的增长关系**。

常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。空间复杂度分析一般要比时间复杂度分析简单。



## 时间复杂度分析

- 最好情况时间复杂度（best case time complexity）
- 最坏情况时间复杂度（worst case time complexity）
- 平均情况时间复杂度（average case time complexity）
- 均摊时间复杂度（amortized time complexity）

最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。

最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。

平均时间复杂度就是，把每种情况发生的概率考虑进去，得到概率论中的的加权平均值，也叫作期望值。所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。

均摊时间复杂度就是，通过摊还分析得到的时间复杂度。对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。

